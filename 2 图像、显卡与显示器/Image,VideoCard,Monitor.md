# 计算机图形学&OpenGL系列教程（二） 图像、显卡与显示器

转载请保留出处

## 为什么有这个内容？

&emsp;&emsp;在上一章中提到，计算机图形学主要研究内容就是研究如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示的相关原理与算法。网上大多数教程都缺失对图像，以及渲染图像的显卡，显示图像的显示器的介绍，然而这些内容又是必要的，只有了解一定的这些内容的原理，才能正确使用OpenGL进行计算机图形学的学习。此外，本章的内容也对于学习数字图像处理，计算机视觉，或者理解现在显卡用于人工神经网络的训练的原理有一定的帮助。

## 图像

### 计算机中表示图像数据的方法

&emsp;&emsp;首先，由于计算机显示器是发光的光源，因此显示的任何颜色都是通过红色(R)，绿色(G)，蓝色(B)所谓的光学三原色合成所得。图形学中也常常使用三原色的信息去表示图像，一个颜色可以用向量(R, G, B)表示。每个分量的范围，如果用整数表示的话常见范围是\[0, 255\](只取整数)，如果用实数表示，则常见范围为\[0, 1\](包含0到1之间所有实数)。一个分量的值越大，则其对应的颜色越“浓”。如果使用整数表示颜色的分量，那么纯红色就是(255, 0, 0)，纯绿色是(0, 255, 0)，纯蓝色是(0, 0, 255)，纯紫色是纯红色与纯蓝色的混合，是(255, 0, 255)。此外，还可以给颜色加入第四个分量，不透明度A(Alpha)，通常用在多张图像的混合中，直观地看，不透明度越大，则在与其它图像叠加合成时，越无法看到在这张图片的下面的图像。(有使用过Photoshop的同学都懂的~)

<img src="./4colors.png">


&emsp;&emsp;计算机中图像都是一个矩形，具有宽度和高度，宽度表示图像在水平方向上的像素数量，高度表示图像在竖直方向上的像素数量。通常我们依照像素在图像内的位置，类似笛卡尔坐标系那样，取图像左上角为原点(0,0)，水平向右方向为x轴正方向，竖直向下方向为y轴正方向，这样给图像的每一个像素编码一个位置坐标(x, y)。以后我们就使用这个位置坐标(x,y)代指位于(x,y)位置的像素点。

<img src="./image_coordinate.png"> 

&emsp;&emsp;每一个像素点上通常储存这一个像素的颜色信息，颜色信息数据的大小(比特数)称作**位深度**，例如图像每一个像素使用3个float储存颜色信息，那么图像的 最终图像的有像素构成了图像。

&emsp;&emsp;这里列出实际编程中常见的两种颜色信息的编码方法：

#### 索引图像

&emsp;&emsp;在索引图像内部，包含一个额外的颜色映射表(color map，简称颜色表)，颜色表内包含了图像中所有用到的颜色color[0], color[1], color[2], ..., 颜色表内所有颜色都由是一个颜色向量(R, G, B)。

&emsp;&emsp;有了颜色表，图像的每一个像素点只储存它表示的颜色在颜色表中的位置(下标)即可。

例如有一张宽度为4，高度为3的索引图像，颜色表为：

```C
color[0] = (255, 0, 0)
color[1] = (0, 0, 255)
```
图像的所有像素为：
```C
1111
0000
1111
```
查颜色表可得，0表示(0,0,255), 1表示(255,0,0)，那么这就看作是一张背景为蓝色，中间一条红线的图像。

#### RGB图像

另一种现在更常用于表示真彩色图片的图像编码方法，则是直接在每一个像素上储存颜色本身，也就是每一个像素直接储存一个(R,G,B)（或者是(R,G,B,A))，表示图像。例如索引图像中的例子，用RGB图像表示就是：

```
(0,0,255)(0,0,255)(0,0,255)(0,0,255)
(255,0,0)(255,0,0)(255,0,0)(255,0,0)
(0,0,255)(0,0,255)(0,0,255)(0,0,255)
```

### 图像数据的储存

&emsp;&emsp;在依上一节的方法，将图像编码成图像数据后，在OpenGL中往往是直接可以使用的。然而我们平常所见的图片文件的情况要更复杂一些。常见的典型的图片文件，有BMP，PNG, JPEG(JPG)三种文件格式，相对应三种图片文件编码方式，BMP是一种无压缩的图片文件格式，将图片信息放在文件头部，后面直接存放原始的颜色表(如果有)和像素数据。PNG是一种无损压缩的图片格式，直接储存图片的像素数据通常比较占用空间，PNG对数据进行了无损压缩。而JPEG是一种有损压缩的图片格式，通常能够得到比PNG格式更小的图片文件，但也会轻微损失图片质量。更加详细的信息参阅<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F/277878?fr=aladdin">百度百科</a>，在我们学习OpenGL的过程中只需要学会使用第三方库读取图片文件得到图像数据，或者是把图像数据写入图片即可。

## 显卡

&emsp;&emsp;显卡(Video Card)在计算机中承担着向显示器输出视频信号的功能，早期的显卡只是一个能够将主机指定的要显示的数据，转化为显示器可以识别并显示出来的设备，还并没有具有独立处理图形的能力；随着技术的发展与需求的迭代，现代的显卡还具有图形处理，并行计算的能力，也能够实现AR,VR等技术， 目前PC端的独立显卡的主要显卡供应厂商为**NVIDIA**(英伟达)和**AMD**(超威半导体公司)，只要采用NVIDIA显示芯片的显卡被称为N卡，采用AMD显示芯片的显卡被称为A卡。本教程无意争论N卡好还是A卡好，要避免意识形态之争，实事求是，与时俱进，凡是有利于学习OpenGL理解计算机图形学的显卡都是好显卡。此外，笔记本电脑往往为了节约功耗，会配备带有集成显卡的处理。

&emsp;&emsp;本教程中提到的显卡指代的都是上文中提到的现代化的显卡，也是同学们电脑上所使用的显卡（如果真的没有，那买新电脑吧）。显卡内含显示芯片，或称图形处理器(Graphics Process Unit, GPU)，具有并行计算能力，并配有专用的显示储存器(简称“显存”)，GPU与显存的关系，就如同CPU与主存(俗称“内存”)的关系。

&emsp;&emsp;GPU的并行计算能力，极大加速了图形处理的速度。我们以NVIDIA20系显卡为例，感性地说明其并行计算能力：

<img src="./NVIDIA_TURING.png">

<img src="./NVIDIA_RMB.png">

<img src="./NVIDIA_CORES.png">

&emsp;&emsp;从上面三张图提供的数据可以直观的看到，GPU具有大量的计算单元（图中的10系和20系旗舰级显卡都有上千个，往往远远超过其搭配的cpu的核心数），在实际使用时可以进行大规模地并行计算。而图形处理正是适合使用并行计算的场景，在之后的学习中我们会发现，我们会对所有输入的图元，以及图元栅格化后所得图像的所有像素，运行同样的一段代码(之后会讲到，在渲染流水线中，我们对输入的所有顶点运行同一个顶点着色器程序，对图像所有像素运行同一个片段着色器程序)，而且互不干扰。如果使用CPU去完成，由于CPU核心数量少，一次能够同时处理的图元或者像素数量少。而GPU有着大量的可并行计算的核心，能够同时为大量的图元或者像素运行程序，这也是GPU在图形处理速度上总远远优于CPU的主要原因。此外，GPU这种大规模并行计算的能力，也被发掘并应用到其它领域，例如机器学习，区块链等。但是GPU也有其自身的局限性，它的单核性能往往远比CPU单核要差，而且由于GPU的特殊构架设计，它只适合进行简单的数学计算，而不适合应对更加复杂的业务场景（比如说GPU上代码使用if条件分支语句会极大损耗性能）。我们可以这样形象地比喻CPU和GPU，CPU是一名博士生，而GPU是一大群小学生，对于大量的简单题目，一大群小学生完成的速度自然比一名博士生要快。然而对于困难的问题，博士生依然可以完成，而一大群小学生也无法完成。

&emsp;&emsp;CPU与与之搭配的主存，GPU有与之搭配的显存，主存和内存中都是可以储存数据的，他们之间也是可以进行数据的交换的。然而主存和显存之间数据传输的速度是远比CPU与主存或是GPU与显存之间的速度要慢的（一般来说要慢一个数量级），因此在实际编程中我们应当尽量避免不必要的主存和显存之间的数据交换。

&emsp;&emsp;对于学习OpenGL和计算机图形学，有关显卡的内容初步了解这些已经可以了。更多内容可以查阅相关资料了解。

## 显示器

（未完待续）